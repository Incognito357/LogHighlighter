#!/bin/bash
function log {		#BASHRC
awkcmd='BEGIN {n="37"}
	function color(str, a, b, m){
		na="38;5;242";
		ma=RSTART;
		ml=RLENGTH;
		if (!match(substr(str, ma+ml, length(out)-(ma+ml)), /(.*? - )/, mm) &&
		    !match(substr(str, ma+ml, length(out)-(ma+ml)), /(.*?\])([a-zA-Z0-9])/, mm) &&
		    !match(substr(str, ma+ml, length(out)-(ma+ml)), /( *?[^ ]*?)/, mm)){
			RSTART=0;
			RLENGTH=1;
		}
		str=sprintf("\033[24;%sm%s\033[%sm%s\033[%sm%s\033[%sm%s",
			na, substr(str, 0, ma-1),
			a, m,
			b, mm[1],
			a, mm[2] substr(str, RSTART+RLENGTH+ma+ml-1, length(str)-(RSTART+RLENGTH-2)));
		print str;
		n=b;
	} {
		if (search != "") out=gensub("("search")", "\033[7m\\1\033[27m", "g");
		else out=$0;
	}
	!/INFO|ERROR|WARN|DEBUG|TRACE|FATAL|^==>.*<==$/ { print "\033[" n "m" out }
	match(out, /(\[?INFO *?\]?)/, m)  { color(out, "36", "38;5;30", m[1]); }
	match(out, /(\[?WARN *?\]?)/, m)  { color(out, "93", "38;5;100", m[1]); }
	match(out, /(\[?ERROR *?\]?)/, m) { color(out, "91", "38;5;124", m[1]); }
	match(out, /(\[?DEBUG *?\]?)/, m) { color(out, "92", "38;5;28", m[1]); }
	match(out, /(\[?TRACE *?\]?)/, m) { color(out, "95", "38;5;90", m[1]); }
	match(out, /(\[?FATAL *?\]?)/, m) { color(out, "4;91", "24;91", m[1]); }
	match(out, /^==>.*<==$/){ print "\033[95m" out }'

version="1.0"
if [[ "$#" -gt "0" ]]; then
	n="30"
	f="-f"
	search=""
	pat="INFO|WARN|DEBUG|ERROR|TRACE|FATAL"
	files=()

	while [[ "$#" -gt "0" ]]; do
		case "$1" in
			-h)     echo "log [options] file [file..N]"
				echo "log can also receive from pipes"
				echo "    -n #          Number of lines to tail (default 30) (ignored in pipe mode)"
				echo "    -p regex      Tail starting from the [n]th last occurrence of the regex pattern"
				echo "                  Defaults to '$pat' (ignored with multiple files)"
				echo "    -s regex      Highlight occurrences of pattern if found (supports regex)"
				echo "    -f            Do not follow the file when tailed (ignored in pipe mode)"
				echo "version: $version"
				exit
				;;
			-n)     shift
				if [[ "$#" -eq "0" ]]; then
					echo "-n: expected a number"
					exit
				fi
				n="$1"
				;;
			-f)     f=""
				;;
			-p)     shift
				if [[ "$#" -eq "0" ]]; then
					echo "-p: expected a pattern to start tail from"
					exit
				fi
				pat="$1"
				;;
			-s)     shift
				if [[ "$#" -eq "0" ]]; then
					echo "-s: expeected a pattern to search for"
					exit
				fi
				search="$1"
				;;
			*)	files+=("$1")
				;;
		esac
		shift
	done

	if [[ ${#files[@]} -gt 0 ]]; then
		if [[ ${#files[@]} -eq 1 ]]; then
			tmp="$n"
			n=$(tac "${files[0]}" | grep -E "$pat" -m$n -n | tac | head -1 | cut -d : -f 1)
			if [[ -z "$n" ]]; then
				n="$tmp"
			fi
		fi
		if [[ -n "$search" ]]; then
			tail -n $n $f "${files[@]}" | awk -v search="$search" "$awkcmd"
		else
			tail -n $n $f "${files[@]}" | awk "$awkcmd"
		fi
	else
		if [[ -n "$search" ]]; then
			awk -v search="$search" "$awkcmd"
		else
			awk "$awkcmd"
		fi
	fi
else
	awk "$awkcmd"
fi
}		#BASHRC
export -f log	#BASHRC
